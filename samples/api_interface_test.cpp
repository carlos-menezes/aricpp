/*******************************************************************************
 * ARICPP - ARI interface for C++
 * Copyright (C) 2017 Daniele Pallastrelli
 *
 * This file is part of aricpp.
 * For more information, see http://github.com/daniele77/aricpp
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 ******************************************************************************/


#include <boost/program_options.hpp>
#include <algorithm>
#include <exception>
#include <iostream>
#include <iterator>
#include <string>
#include <vector>

#include "../aricpp/client.h"
#include "../aricpp/channel.h"
#include "../aricpp/bridge.h"
#include "../aricpp/channelset.h"


#if 0
/****************************************/

namespace aricpp
{


class ChannelSet
{
public:

    using ChannelPtr = std::shared_ptr<Channel>;

    ChannelSet(Client& c) : client(c) { Subscribe(); }

    ChannelSet(const ChannelSet&) = delete;
    ChannelSet(const ChannelSet&&) = delete;
    ChannelSet& operator=(const ChannelSet&) = delete;
    ChannelSet& operator=(const ChannelSet&&) = delete;

    using ChHandler = std::function<void(ChannelPtr)>;
    using StasisStartedHandler = std::function<void(ChannelPtr, bool)>;

    void OnChannelCreated(ChHandler handler) { chCreated = handler; }
    void OnChannelDestroyed(ChHandler handler) { chDestroyed = handler; }
    void OnChannelStateChanged(ChHandler handler) { chStateChanged = handler; }
    void OnStasisStarted(StasisStartedHandler handler) { stasisStarted = handler; }

    template<typename ErrorHandler, typename CompletionHandler>
    ChannelPtr CreateChannelAndDial(const std::string& ext, const std::string& app, const std::string caller, ErrorHandler error, CompletionHandler after)
    {
        // generate an id for the called
        const std::string id = "aricpp-" + std::to_string(nextId++);
        auto it = channels.emplace(id, std::make_shared<Channel>(client, id));
        auto ch = it.first->second;
        ch->Call(ext, app, caller, "internal")
            .Error([error](boost::system::error_code e) { error(e); } )
            .After([after](int s) { after(s); } );
        return ch;
    }

private:

    void Subscribe()
    {
        client.OnEvent(
            "ChannelCreated",
            [this](const JsonTree& e)
            {
                auto state = Get<std::string>( e, {"channel", "state"} );
                auto id = Get<std::string>( e, {"channel", "id"} );
                auto findResult = channels.find(id);
                std::shared_ptr<Channel> channel;
                if ( findResult == channels.end() )
                {
                    auto it = channels.emplace(id, std::make_shared<Channel>(client, id, state));
                    channel = it.first->second;
                }
                else
                {
                    channel = findResult->second;
                    channel->StateChanged(state);
                }
                if (chCreated) chCreated(channel);
            }
        );

        client.OnEvent(
            "StasisStart",
            [this](const JsonTree& e)
            {
                const std::string id = Get<std::string>( e, {"channel", "id"} );
                const std::string name = Get<std::string>( e, {"channel", "name"} );
                const std::string ext = Get<std::string>( e, {"channel", "dialplan", "exten"} );
                const std::string callerNum = Get<std::string>( e, {"channel", "caller", "number"} );
                const std::string callerName = Get<std::string>( e, {"channel", "caller", "name"} );
                const auto& args = Get<std::vector<std::string>>( e, {"args"} );

                auto ch = channels.find(id);
                if ( ch == channels.end() ) return;

                ch->second->StasisStart(name, ext, callerNum, callerName);
                if (stasisStarted) stasisStarted(ch->second, args.empty());
            }
        );
        client.OnEvent(
            "ChannelDestroyed",
            [this](const JsonTree& e)
            {
                auto id = Get<std::string>( e, {"channel", "id"} );

                auto ch = channels.find(id);
                if ( ch == channels.end() ) return;
                ch->second->Dead();
                if (chDestroyed) chDestroyed(ch->second);
                channels.erase(id);
            }
        );
        client.OnEvent(
            "ChannelStateChange",
            [this](const JsonTree& e)
            {
                auto id = Get<std::string>( e, {"channel", "id"} );
                auto state = Get<std::string>( e, {"channel", "state"} );
                auto ch = channels.find(id);
                if ( ch == channels.end() ) return;
                ch->second->StateChanged(state);
                if (chStateChanged) chStateChanged(ch->second);
            }
        );
/*
        client.OnEvent(
            "BridgeCreated",
            [this](const JsonTree& e)
            {
                auto id = Get<std::string>( e, {"bridge", "id"} );
                bridges.emplace( id, std::move(Bridge(id, client)) );
            }
        );
        client.OnEvent(
            "BridgeDestroyed",
            [this](const JsonTree& e)
            {
                auto id = Get<std::string>( e, {"bridge", "id"} );
                bridges.erase( id );
            }
        );
*/
    }

    Client& client;
    std::unordered_map<std::string, ChannelPtr> channels;
//    std::unordered_map<std::string, Bridge> bridges;
    unsigned long long nextId = 0;

    ChHandler chCreated;
    ChHandler chDestroyed;
    ChHandler chStateChanged;
    StasisStartedHandler stasisStarted;
};

}

/****************************************/
#endif

using namespace aricpp;
using namespace std;

enum class ChMode { calling=1, called=2, both=3 };

class Call
{
public:
    Call( Client& c, shared_ptr<Channel> callingCh, shared_ptr<Channel> calledCh ) :
        client(&c), calling(callingCh), called(calledCh)
    {}

    bool HasChannel(const Channel& ch, ChMode mode) const
    {
        return ( ( ( calling->Id() == ch.Id() ) && ( static_cast<int>(mode) & static_cast<int>(ChMode::calling) ) ) ||
                 ( ( called->Id()  == ch.Id() ) && ( static_cast<int>(mode) & static_cast<int>(ChMode::called)  ) ) );
    }

    void DialedChRinging() { calling->Ring(); }

    void DialedChStart() { calling->Answer(); }

    void DialingChUp()
    {
        bridge = make_unique<Bridge>(
            *client,
            [this](){ bridge->Add( {&*calling, &*called} ); });
    }

    bool ChHangup(shared_ptr<Channel> hung)
    {
        shared_ptr<Channel> other = ( hung->Id() == called->Id() ? calling : called );

        if ( !other->IsDead() ) other->Hangup();
        return ( other->IsDead() );
    }

private:

    Client* client;
    shared_ptr<Channel> calling;
    shared_ptr<Channel> called;
    unique_ptr<Bridge> bridge;
};

class CallContainer
{
public:
    CallContainer(const string& app, Client& c, ChannelSet& m) : application(app), connection(c), model(m)
    {
        model.OnStasisStarted(
            [this](shared_ptr<Channel> ch, bool external)
            {
                if (external) CallingChannel( ch );
                else CalledChannel( ch );
            }
        );
        model.OnChannelDestroyed(
            [this](shared_ptr<Channel> ch)
            {
                auto call = FindCallByChannel(ch, ChMode::both);
                if (call)
                {
                    if ( call->ChHangup(ch) )
                        Remove(call);
                }
                else
                    cerr << "Call with a channel " << ch->Id() << " not found (hangup event)" << endl;
            }
        );
        model.OnChannelStateChanged(
            [this](shared_ptr<Channel> ch)
            {
                auto state = ch->GetState();
                if (state == Channel::State::ringing)
                {
                    auto call = FindCallByChannel(ch, ChMode::called);
                    if (call)
                        call->DialedChRinging();
                    else
                        cerr << "Call with dialed ch id " << ch->Id() << " not found (ringing event)\n";
                }
                else if (state == Channel::State::up)
                {
                    auto call = FindCallByChannel(ch, ChMode::calling);
                    if (call)
                        call->DialingChUp();
                }
            }
        );
    }
    CallContainer(const CallContainer&) = delete;
    CallContainer(CallContainer&&) = delete;
    CallContainer& operator=(const CallContainer&) = delete;

private:

    void CallingChannel(const shared_ptr<Channel> callingCh)
    {
        const string callingId = callingCh->Id();
        const string name = callingCh->Name();
        const string ext = callingCh->Extension();
        const string callerNum = callingCh->CallerNum();
        string callerName = callingCh->CallerName();
        if (callerName.empty()) callerName = callerNum;

        // TODO better using .Error().After() but then, how can I return the channel?
        auto calledCh = model.CreateChannelAndDial("sip/"s+ext, application, callerName,
            [](boost::system::error_code e)
            {
                cerr << "Error creating channel: " << e.message() << '\n';
            },
            [callingCh](int s)
            {
                if (s/100 != 2)
                {
                    cerr << "Error: status code " << s << '\n';
                    callingCh->Hangup();
                }
                else
                    cout << "Call ok\n";
            }
        );

        Create(callingCh, calledCh);
    }

    void CalledChannel(const shared_ptr<Channel> calledCh)
    {
        auto call = FindCallByChannel(calledCh, ChMode::called);
        if (call)
            call->DialedChStart();
        else
            cerr << "Call with dialed ch id " << calledCh->Id() << " not found (stasis start event)\n";
    }

    void Create(shared_ptr<Channel> callingCh, shared_ptr<Channel> calledCh)
    {
        calls.emplace_back(make_shared<Call>(connection, callingCh, calledCh));
    }

    void Remove(shared_ptr<Call> call)
    {
        calls.erase(remove(calls.begin(), calls.end(), call), calls.end());
    }

    // return the index of the call in the vector.
    // return calls.size() if not found
    shared_ptr<Call> FindCallByChannel(const shared_ptr<Channel> ch, ChMode mode) const
    {
        auto c = find_if(calls.begin(), calls.end(), [&](auto call){ return call->HasChannel(*ch, mode); });
        return ( c == calls.end() ? shared_ptr<Call>() : *c );
    }

    const string application;
    Client& connection;
    vector<shared_ptr<Call>> calls;
    ChannelSet& model;
};


int main( int argc, char* argv[] )
{
    try
    {
        string host = "localhost";
        string port = "8088";
        string username = "asterisk";
        string password = "asterisk";
        string application = "attendant";

        namespace po = boost::program_options;
        po::options_description desc("Allowed options");
        desc.add_options()
            ("help,h", "produce help message")
            ("version,V", "print version string")

            ("host,H", po::value(&host), ("ip address of the ARI server ["s + host + ']').c_str())
            ("port,P", po::value(&port), ("port of the ARI server ["s + port + "]").c_str())
            ("username,u", po::value(&username), ("username of the ARI account on the server ["s + username + "]").c_str())
            ("password,p", po::value(&password), ("password of the ARI account on the server ["s + password + "]").c_str())
            ("application,a", po::value(&application), ("stasis application to use ["s + application + "]").c_str())
        ;

        po::variables_map vm;
        po::store(po::parse_command_line(argc, argv, desc), vm);
        po::notify(vm);

        if (vm.count("help"))
        {
            cout << desc << "\n";
            return 0;
        }

        if (vm.count("version"))
        {
            cout << "This is dial application v. 1.0, part of aricpp library\n";
            return 0;
        }

        boost::asio::io_service ios;

        // Register to handle the signals that indicate when the server should exit.
        // It is safe to register for the same signal multiple times in a program,
        // provided all registration for the specified signal is made through Asio.
        boost::asio::signal_set signals(ios);
        signals.add(SIGINT);
        signals.add(SIGTERM);
#if defined(SIGQUIT)
        signals.add(SIGQUIT);
#endif // defined(SIGQUIT)
        signals.async_wait(
            [&ios](boost::system::error_code /*ec*/, int /*signo*/)
            {
                cout << "Cleanup and exit application...\n";
                ios.stop();
            });

        Client client( ios, host, port, username, password, application );
        ChannelSet ariModel( client );
        CallContainer calls( application, client, ariModel );

        client.Connect( [&](boost::system::error_code e){
            if (e)
            {
                cerr << "Connection error: " << e.message() << endl;
                ios.stop();
            }
            else
                cout << "Connected" << endl;
        });

        ios.run();
    }
    catch ( exception& e )
    {
        cerr << "Exception in app: " << e.what() << ". Aborting\n";
        return -1;
    }
    return 0;
}
