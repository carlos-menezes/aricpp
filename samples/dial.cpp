/*******************************************************************************
 * ARICPP - ARI interface for C++
 * Copyright (C) 2017 Daniele Pallastrelli
 *
 * This file is part of aricpp.
 * For more information, see http://github.com/daniele77/aricpp
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 ******************************************************************************/


#include <boost/program_options.hpp>
#include <algorithm>
#include <exception>
#include <iostream>
#include <iterator>
#include <string>
#include <vector>
#include <map>

#include "../aricpp/client.h"

/*

116 ---INVITE--> 132
116 <--TRYING--- 132

Create and dial 132
POST /ari/channels?endpoint=sip/291&app=attendant

                 132 ---INVITE--> 41
                 132 <--TRYING--- 41
                 132 <--RINGING-- 41

Ring 116
POST /ari/channels/<channel>/ring

116 <--RINGING-- 132

41 answers

                 132 <----OK----- 41
                 132 ----ACK----> 41

Answer 116
POST /ari/channels/<channel>/answer

116 <----OK----- 132
116 -----ACK---> 132

Bridge
POST /ari/bridges?type=mixing
POST /ari/bridges/<bridge>/addChannel?channel=<channel>&role=partecipant
POST /ari/bridges/<bridge>/addChannel?channel=<channel>&role=partecipant

                 132 ---INVITE--> 41
                       in-dialog
116 <--INVITE--- 132
      in-dialog
116 -----OK----> 132
116 <----ACK---- 132
                 132 <--TRYING--- 41
                 132 <----OK----- 41
                 132 ----ACK----> 41
                 132 ---INVITE--> 41
                       in-dialog

 */

//#define CALL_TRACE

using namespace aricpp;
using namespace std;

class Call
{
public:
    using Id = size_t;

    Call(const Call&) = default;
    Call& operator=(const Call&) = delete;
    Call& operator=(Call&&) = default;

    Call(Client& c, const string& chId) : connection( &c )
    {
        channels.push_back(chId);
#ifdef CALL_TRACE
        cout << "Call " << id << " created with ch=" << chId << '\n';
#endif
    }
#ifdef CALL_TRACE
    ~Call()
    {
        cout << "Call " << id << " destroyed\n";
    }
#endif
    bool HasChannel(const string& ch) const
    {
        return find(channels.begin(), channels.end(), ch) != channels.end();
    }
    void AddCh(const string& ch)
    {
        channels.push_back(ch);
#ifdef CALL_TRACE
        cout << "Call " << id << " add ch=" << ch << '\n';
#endif
    }
    // returns true if the calls has no more channels
    bool RemoveCh(const string& ch)
    {
#ifdef CALL_TRACE
        cout << "Call " << id << " remove ch=" << ch << '\n';
#endif
        channels.erase(remove(channels.begin(), channels.end(), ch), channels.end());
        if (channels.empty() && ! bridge.empty())
        {
            connection->RawCmd( "DELETE", "/ari/bridges/"+bridge, [](auto,auto,auto,auto){});
        }
        else if (channels.size() == 1)
        {
            connection->RawCmd( "DELETE", "/ari/channels/"+channels[0], [](auto,auto,auto,auto){});
        }
        return channels.empty();
    }
    void Bridge(const string& bridgeId)
    {
#ifdef CALL_TRACE
        cout << "Call " << id << " bridge\n";
#endif
        bridge = bridgeId;
        assert(channels.size() == 2);
        connection->RawCmd( "POST", "/ari/bridges/"+bridge+"/addChannel?channel="+channels[0]+","+channels[1], [](auto e,auto s,auto r,auto){
            if (e)
            {
                cerr << "Error in bridge request: " << e.message() << '\n';
                return;
            }
            if ( s/100 != 2 )
            {
                cerr << "Negative response in bridge request: " << s << ' ' << r << '\n';
                return;
            }

        });
    }
    void Dump() const
    {
        cout << "--- Call " << id << " dump:\n";
        cout << "\tbridge=" << bridge << endl;
        for_each(channels.begin(), channels.end(), [](auto& c){
            cout << "\tch=" << c << endl;
        });
    }
    Id GetId() const { return id; }
    static const Id Invalid = 0;

private:
    static Id globalId;
    Client* connection;
    string bridge{};
    vector<string> channels;
    Id id = ++globalId;
};

Call::Id Call::globalId = 0;

class CallContainer
{
public:
    CallContainer() = default;
    CallContainer(const CallContainer&) = delete;
    CallContainer(CallContainer&&) = delete;
    CallContainer& operator=(const CallContainer&) = delete;
    void Set(Client& c) { connection = &c; }
    Call* GetFromCh(const string& chId)
    {
        auto it = find_if(calls.begin(), calls.end(), [&chId](const Call& call){ return call.HasChannel(chId); });
        if (it == calls.end()) return nullptr;
        return &(*it);
    }
    // Creates a new call having a given channel
    void Create(const string& chId)
    {
#ifdef CALL_TRACE
        cout << "create call from ch id: " << chId << '\n';
#endif
        calls.emplace_back(*connection, chId);
    }
    void Remove(const Call::Id c)
    {
#ifdef CALL_TRACE
        cout << "removing call " << c << '\n';
#endif
        calls.erase(
            remove_if(
                calls.begin(),
                calls.end(),
                [c](const Call& curr){ return c == curr.GetId(); }
            ),
            calls.end()
        );
#ifdef CALL_TRACE
        cout << "calls# = " << calls.size() << "\n";
#endif
    }
    void Dump() const
    {
        cout << "*** CallContainer Dump:\n";
        for_each(calls.begin(), calls.end(), [](auto& c){ c.Dump(); });
        cout << '\n';
    }
    size_t Size() const { return calls.size(); }
private:
    Client* connection;
    vector<Call> calls;
};


struct Rule
{
    using Predicate = function<bool(const Event&)>;
    using Action = function<void(const Event&)>;
    Rule(string&& type, Predicate p, Action a, bool trans=false) :
        eventType(move(type)), predicate(p), action(a), transient(trans), toRemove(false) {}
    void Exec(const Event& e)
    {
        if( toRemove ) return;
        if ( predicate(e) )
        {
            action(e);
            toRemove = transient;
        }
        else
            toRemove = false;
    }
    bool ShouldRemove() const { return toRemove; }
    const string eventType;
private:
    const Predicate predicate;
    const Action action;
    const bool transient;
    bool toRemove;
};

class RuleSet
{
public:
    explicit RuleSet(boost::asio::io_service& ios) : ioservice(ios) {}
    auto Add(Rule&& r)
    {
        GC();
        return rules.insert(make_pair(r.eventType, move(r)));
    }
    template < typename R >
    void Remove(R r)
    {
        rules.erase(r);
    }
    void HandleEvent(const Event& e)
    {
        // dipatch the event:
        auto type = e.at("type");
        auto range = rules.equal_range( type );
        for_each( range.first, range.second, [&e,this](auto& item){
            auto& rule = item.second;
            ioservice.post( [&rule,e](){ rule.Exec(e); } );
        });
    }

private:
    void GC()
    {
        // clean the set:
        for( auto i = rules.begin(); i != rules.end(); )
        {
            if( i->second.ShouldRemove() )
                i = rules.erase(i);
            else
                ++i;
        }
    }
    boost::asio::io_service& ioservice;
    multimap< string, Rule > rules;
};

int main( int argc, char* argv[] )
{
    try
    {
        string host = "localhost";
        string port = "8088";
        string username = "asterisk";
        string password = "asterisk";
        string application = "attendant";

        namespace po = boost::program_options;
        po::options_description desc("Allowed options");
        desc.add_options()
            ("help,h", "produce help message")
            ("version,V", "print version string")

            ("host,H", po::value(&host), ("ip address of the ARI server ["s + host + ']').c_str())
            ("port,P", po::value(&port), ("port of the ARI server ["s + port + "]").c_str())
            ("username,u", po::value(&username), ("username of the ARI account on the server ["s + username + "]").c_str())
            ("password,p", po::value(&password), ("password of the ARI account on the server ["s + password + "]").c_str())
            ("application,a", po::value(&application), ("stasis application to use ["s + application + "]").c_str())
        ;

        po::variables_map vm;
        po::store(po::parse_command_line(argc, argv, desc), vm);
        po::notify(vm);

        if (vm.count("help"))
        {
            cout << desc << "\n";
            return 0;
        }

        if (vm.count("version"))
        {
            cout << "This is dial application v. 1.0, part of aricpp library\n";
            return 0;
        }

        unsigned long long nextId = 0;

        boost::asio::io_service ios;

        // Register to handle the signals that indicate when the server should exit.
        // It is safe to register for the same signal multiple times in a program,
        // provided all registration for the specified signal is made through Asio.
        boost::asio::signal_set signals(ios);
        signals.add(SIGINT);
        signals.add(SIGTERM);
#if defined(SIGQUIT)
        signals.add(SIGQUIT);
#endif // defined(SIGQUIT)
        signals.async_wait(
            [&ios](boost::system::error_code /*ec*/, int /*signo*/)
            {
                cout << "Cleanup and exit application...\n";
                ios.stop();
            });

        CallContainer calls;
        Client client( ios, host, port, username, password, application );
        calls.Set(client);
        RuleSet rules( ios );

        rules.Add(
            Rule( "StasisStart",
                [](const Event& e)
                {
                    const auto& args = e.at("args");
                    return ( args.empty() );
                },
                [&calls,&client,&application,&rules,&nextId](const Event& e)
                {
                    const auto& ch = e.at("channel");
                    const std::string id = ch.at("id");
                    const std::string name = ch.at("name");
                    const std::string ext = ch.at("dialplan").at("exten");
                    const auto& caller = ch.at("caller");
                    const std::string callerNum = caller.at("number");
                    std::string callerName = caller.at("name");
                    if (callerName.empty()) callerName = callerNum;

                    // generate an id for the called
                    const string dialedId = "aricpp-" + to_string( nextId++ );

                    // create a new call object
                    calls.Create(id);

                    // schedule adding dialed channel to the call
                    auto r1 = rules.Add(
                        Rule( "ChannelCreated",
                            [dialedId](const Event& ev)
                            {
                                auto dId = ev.at("channel").at("id");
                                return (dId == dialedId);
                            },
                            [&calls,dialedId,id](const Event&)
                            {
                                auto call = calls.GetFromCh(id);
                                if (call == nullptr)
                                {
                                    cerr << "(AddCh) Warning: no call found with ch="+id+"\n";
                                    calls.Dump();
                                    assert(false);
                                    return;
                                }
                                call->AddCh(dialedId);
                            },
                            true )  // transient rule
                    );

                    // schedule ringing
                    auto r2 = rules.Add(
                        Rule( "ChannelStateChange",
                            [dialedId](const Event& ev)
                            {
                                auto state = ev.at("channel").at("state");
                                auto id = ev.at("channel").at("id");
                                return (state == "Ringing" && id == dialedId);
                            },
                            [&client,id](const Event&)
                            {
                                client.RawCmd( "POST", "/ari/channels/"+id+"/ring", [](auto e,auto s,auto r,auto){
                                    if (e)
                                    {
                                        cerr << "Error in ring request: " << e.message() << '\n';
                                        return;
                                    }
                                    if ( s/100 != 2 )
                                    {
                                        cerr << "Negative response in ring request: " << s << ' ' << r << '\n';
                                        return;
                                    }
                                });
                            },
                            true )  // transient rule
                    );

                    auto r3 = rules.Add(
                        Rule( "ChannelDestroyed",
                            [dialedId](const Event& ev)
                            {
                                auto evId = ev.at("channel").at("id");
                                return (evId == dialedId);
                            },
                            [&rules,r2](const Event& ev)
                            {
                                int cause = ev.at("cause");
                                if (cause == 17) // user busy
                                    rules.Remove( r2 );
                            },
                            true ) // transient rule
                    );

                    // call the called party
                    client.RawCmd(
                        "POST",
                        "/ari/channels?"
                        "endpoint=sip/"+ext+
                        "&app="+application+
                        "&channelId="+dialedId+
                        "&callerId="+callerName+
                        "&timeout=-1"
                        "&appArgs=dialed,"+id,
                        [&client,id,r1,r2,r3,&rules](auto e,auto s,auto r,auto)
                        {
                            if (e) cerr << "Error creating channel: " << e.message() << '\n';
                            if (s/100 != 2)
                            {
                                cerr << "Error: status code " << s << " reason: " << r << '\n';
                                rules.Remove( r1 );
                                rules.Remove( r2 );
                                rules.Remove( r3 );

                                client.RawCmd( "DELETE", "/ari/channels/"+id, [](auto,auto,auto,auto){});
                            }
                         }
                    );
                }
        ) );

        rules.Add(
            Rule( "StasisStart",
                [](const Event& e)
                {
                    const auto& args = e.at("args");
                    return ( !args.empty() && args[0] == "dialed" );
                },
                [&rules,&calls,&client](const Event& e)
                {
                    const auto& args = e.at("args");
                    const std::string originatingCh = args[1];

                    // schedule bridge
                    auto rule = rules.Add(
                        Rule( "ChannelStateChange",
                            [originatingCh](const Event& ev)
                            {
                                const auto& channel = ev.at("channel");
                                auto state = channel.at("state");
                                auto id = channel.at("id");
                                return (state == "Up" && id == originatingCh);
                            },
                            [originatingCh,&client,&calls](const Event&)
                            {
                                client.RawCmd( "POST", "/ari/bridges?type=mixing", [&calls,&client,originatingCh](auto e,auto s,auto r,auto body){
                                    if (e)
                                    {
                                        cerr << "Error in bridge request: " << e.message() << '\n';
                                        return;
                                    }
                                    if ( s/100 != 2 )
                                    {
                                        cerr << "Negative response in bridge request: " << s << ' ' << r << '\n';
                                        return;
                                    }

                                    auto tree = nlohmann::json::parse( body );
                                    const std::string bridge = tree.at("id");

                                    auto call = calls.GetFromCh(originatingCh);
                                    if (call)
                                        // add the channels to the bridge
                                        call->Bridge(bridge);
                                    else // one of the channel hung up in the meantime
                                    {
                                        cerr << "(bridge) Warning: no call found with ch="+originatingCh+": destroying bridge\n";
                                        client.RawCmd( "DELETE", "/ari/bridges/" + bridge, [](auto,auto,auto,auto){} );
                                        return;
                                    }
                                });
                            },
                            true )  // transient rule
                    );

                    client.RawCmd( "POST", "/ari/channels/"+originatingCh+"/answer",[&calls,originatingCh,&rules,rule](auto,auto status,auto,auto){
                        if (status == 500) // Internal Server Error (the channel does not exist anymore)
                        {
                            rules.Remove(rule);
                        }
                    });
                }
            )
        );

        rules.Add( Rule( "ChannelDestroyed",
                         [](auto){ return true; },
                         [&calls](const Event& e)
                         {
                             auto id = e.at("channel").at("id");
                             // look for the call with the given channel
                             auto call = calls.GetFromCh(id);
                             if (call == nullptr)
                             {
                                 cerr << "WARNING: no call found with ch id=" << id << '\n';
                                 // calls.Dump();
                                 // assert(false);
                                 return;
                             }
                             if (call->RemoveCh(id)) // no more channels: should remove the call
                                 calls.Remove(call->GetId());
                         }
        ) );

        client.Connect( [&](boost::system::error_code ){
            client.OnEvent( "StasisStart", [&](const Event& e){
                //Dump(e);
                rules.HandleEvent(e);
            });
            client.OnEvent("ChannelCreated", [&rules](const Event& e){
                //Dump(e);
                rules.HandleEvent(e);
            });
            client.OnEvent( "ChannelDestroyed", [&](const Event& e){
                //Dump(e);
                rules.HandleEvent(e);
            });
            client.OnEvent("ChannelStateChange", [&rules](const Event& e){
                //Dump(e);
                rules.HandleEvent(e);
            });
        });
        ios.run();
    }
    catch ( exception& e )
    {
        cerr << "Exception in app: " << e.what() << ". Aborting\n";
        return -1;
    }
    return 0;
}
